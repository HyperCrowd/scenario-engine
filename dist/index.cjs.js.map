{
  "version": 3,
  "sources": ["../src/index.ts", "../src/table.ts", "../src/tableManager.ts", "../src/rng.ts", "../src/scenario.ts", "../src/scenarioEvent.ts", "../src/outcome.ts", "../src/tableEntry.ts", "../src/tag.ts"],
  "sourcesContent": ["// Main exports\nexport { default as Scenario } from './scenario'\nexport { default as ScenarioEvent } from './scenarioEvent'\nexport { default as Outcome } from './outcome'\nexport { default as Table } from './table'\nexport { default as TableEntry } from './tableEntry'\nexport { default as TableManager } from './tableManager'\nexport { default as Tag } from './tag'\nexport { default as SimpleSeededRNG } from './rng'\n", "import TableEntry from './tableEntry'\nimport TableManager from './tableManager'\n\n/**\n * Represents a table of entries that can be queried based on numeric input.\n * Automatically registers itself with the TableManager singleton.\n */\nexport default class Table {\n  name: string\n  entries: TableEntry[]\n\n  /**\n   * @param name - The unique name of the table.\n   * @param entries - Optional array of entries to initialize the table with.\n   */\n  constructor(name: string, entries: TableEntry[] = []) {\n    this.name = name\n    this.entries = entries\n\n    // Automatically register with TableManager\n    TableManager.registerTable(this)\n  }\n\n  /**\n   * Adds a new entry to the table.\n   * @param entry - The entry to add.\n   */\n  addEntry(entry: TableEntry): void {\n    this.entries.push(entry)\n  }\n\n  /**\n   * Gets the highest `end` value across all entries in the table.\n   * Useful for determining the max rollable number.\n   * @returns The maximum end value or 0 if the table is empty.\n   */\n  getMaxValue(): number {\n    if (this.entries.length === 0) return 0\n    return Math.max(...this.entries.map(entry => entry.end))\n  }\n\n  /**\n   * Retrieves the entry that matches a given numeric input.\n   * @param value - The number to look up.\n   * @returns The matching entry, or null if no match is found.\n   */\n  getEntry(value: number): TableEntry | null {\n    return this.entries.find(entry => entry.matches(value)) ?? null\n  }\n}\n", "import Table from './table'\n\n/**\n * Singleton manager that keeps track of all registered tables.\n * Tables are registered automatically upon instantiation.\n */\nconst TableManager = (() => {\n  const tables: Map<string, Table> = new Map()\n\n  return {\n    /**\n     * Registers a new table by name.\n     */\n    registerTable(table: Table) {\n      if (!(table instanceof Table)) {\n        throw new Error(\"Only instances of Table can be registered.\")\n      }\n      \n      if (tables.has(table.name)) {\n        throw new Error(`Table with name \"${table.name}\" is already registered.`)\n      }\n      tables.set(table.name, table)\n    },\n\n    /**\n     * Retrieves a registered table by name.\n     */\n    getTable(name: string) {\n      return tables.get(name) || null;\n    },\n\n    /**\n     * Retrieves all registered tables.\n     */\n    getAllTables() {\n      return Array.from(tables.values());\n    },\n\n    /**\n     * Clears all registered tables.\n     * Useful for resetting state between tests.\n     */\n    clearAll() {\n      tables.clear()\n    }\n  }\n})()\n\nexport default TableManager\n", "/**\n * SimpleSeededRNG\n *\n * Lightweight deterministic RNG for browsers.\n * Based on Mulberry32: fast, good-quality random stream from a seed.\n * If no seed is provided, uses crypto.getRandomValues for unseeded randomness.\n */\nexport default class SimpleSeededRNG {\n  private state: number\n\n  constructor(seed?: number | string) {\n    if (seed === undefined) {\n      // Use cryptographically secure randomness\n      const array = new Uint32Array(1)\n      crypto.getRandomValues(array)\n      this.state = array[0]\n    } else if (typeof seed === 'string') {\n      let h = 1779033703 ^ seed.length\n      for (let i = 0; i < seed.length; i++) {\n        h = Math.imul(h ^ seed.charCodeAt(i), 3432918353)\n        h = (h << 13) | (h >>> 19)\n      }\n      this.state = h >>> 0\n    } else {\n      this.state = seed >>> 0\n    }\n  }\n\n  /** Returns a float between 0 (inclusive) and 1 (exclusive). */\n  random(): number {\n    this.state += 0x6D2B79F5\n    let t = this.state\n    t = Math.imul(t ^ (t >>> 15), t | 1)\n    t ^= t + Math.imul(t ^ (t >>> 7), t | 61)\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296\n  }\n\n  /** Returns an integer between min (inclusive) and max (exclusive). */\n  randomInt(min: number, max: number): number {\n    return Math.floor(this.random() * (max - min)) + min\n  }\n}\n", "import TableManager from './tableManager'\nimport TableEntry from './tableEntry'\nimport ScenarioEvent from './scenarioEvent'\nimport Outcome from './outcome'\nimport SimpleSeededRNG from './rng'\nimport Table from './table'\n\ntype Tags = Map<string, number>\n\ntype PathEvent = {\n  tableName: string\n  entry: string\n  roll: number,\n  tags: Map<string, number>\n}\n\n/**\n * Represents a Scenario which chains table entries through Events and Outcomes.\n */\nexport default class Scenario {\n  /** Name of the scenario */\n  name: string\n  /** RNG providing random() and randomInt(max) */\n  rng: SimpleSeededRNG\n  /** Registered events in this scenario */\n  events: ScenarioEvent[]\n\n  /**\n   * Constructor\n   */\n  constructor(name: string, rng: SimpleSeededRNG = new SimpleSeededRNG()) {\n    this.name = name\n    this.rng = rng\n    this.events = []\n  }\n\n  /**\n   * Gets a table\n   */\n  private getTable (tableName: string)  {\n    const table = TableManager.getTable(tableName)\n\n    if (!table) {\n      throw new Error(`Table \"${tableName}\" not found.`)\n    }\n\n    return table\n  }\n\n  /**\n   * Gets a Table Entry\n   */\n  private getEntry (table: Table, accumulatedTags: Map<string, number>) {\n    const roll = this.rng.randomInt(0, table.getMaxValue()) + 1\n    const entry = table.getEntry(roll)\n\n    if (!entry) {\n      throw new Error(`No entry found for roll ${roll} in table \"${table.name}\".`)\n    }\n\n    if (entry.tags && entry.tags.length > 0) {\n      for (const tag of entry.tags) {\n        accumulatedTags.set(tag.name, (accumulatedTags.get(tag.name) || 0) + tag.value)\n      }\n    }\n\n    return {\n      roll, entry\n    }\n  }\n\n  /**\n   * Gets a random Outcome from a Scenario Event\n   */\n  private getRandomOutcome(scenarioEvent: ScenarioEvent, outcomes: Outcome[] = scenarioEvent.outcomes): Outcome | false  {\n    const cumulative: { outcome: Outcome; cumulativeLikelihood: number }[] = []\n    let sum = 0\n\n    for (const outcome of outcomes) {\n      sum += outcome.likelihood\n      cumulative.push({ outcome, cumulativeLikelihood: sum })\n    }\n\n    const rand = this.rng.random() * sum\n    const outcome = cumulative.find(({ cumulativeLikelihood }) => rand <= cumulativeLikelihood)?.outcome\n\n    if (!outcome) {\n      return false\n    }\n\n    return outcome\n  }\n\n  private getPossibleOutcomes (scenarioEvent: ScenarioEvent, accumulatedTags: Tags) {\n    const hasThresholds = scenarioEvent.outcomes.filter(outcome => {\n      return outcome.tagThresholds && outcome.tagThresholds.length > 0\n    }).length > 0\n\n    const possibleOutcomes: Outcome[] = scenarioEvent.outcomes.filter(outcome => {\n      if (hasThresholds) {\n        // This scenario event has thresholds, use them\n        if (!outcome.tagThresholds || outcome.tagThresholds.length === 0) {\n          return false\n        }\n\n        return outcome.tagThresholds.every(({ name, minValue }) => {\n          return (accumulatedTags.get(name) || 0) >= minValue\n        })\n      } else {\n        // This scenario event has no thresholds, use them\n        return outcome\n      }\n    })\n\n    if (hasThresholds && possibleOutcomes.length === 0) {\n      // All threshold checks have failed, use all non-thresholded outcomesinstead\n      return scenarioEvent.outcomes.filter(outcome => {\n        return outcome.tagThresholds && outcome.tagThresholds.length === 0\n      })\n    } else {\n      // Return all possible outcomes\n      return possibleOutcomes\n    }\n  }\n\n  /**\n   * Gets the next outcome of a Scenario Event\n   */\n  private getNextOutcome(scenarioEvent: ScenarioEvent, criteria?: { byTableName?: string, randomly?: boolean, byTags?: Tags}): Outcome | undefined {\n    let outcome: Outcome | undefined\n\n    if (criteria !== undefined) {\n      const accumulatedTags = criteria.byTags ?? new Map<string, number>()\n      const possibleOutcomes = this.getPossibleOutcomes(scenarioEvent, accumulatedTags)\n\n      if (accumulatedTags.size > 0) {\n        /**\n         * Find outcome by tags\n         **/\n        const possibleOutcome = this.getRandomOutcome(scenarioEvent, possibleOutcomes)\n\n        if (possibleOutcome) {\n          outcome = possibleOutcome\n        }\n      }\n      \n      if (outcome === undefined && criteria.randomly) {\n        /**\n         * Find outcome by probability\n         */\n        const possibleOutcome = this.getRandomOutcome(scenarioEvent, possibleOutcomes)\n\n        if (possibleOutcome) {\n          outcome = possibleOutcome\n        }\n      }\n      \n      if (outcome === undefined && criteria.byTableName) {\n        /**\n         * Find outcome by table name\n         */\n        const possibleOutcome = scenarioEvent.outcomes.find((o) => o.tableName === criteria.byTableName)\n\n        if (possibleOutcome) {\n          outcome = possibleOutcome\n        }\n      }\n    } else if (criteria === undefined) {\n      /**\n       * Find outcome by probability\n       */\n      const possibleOutcome = this.getRandomOutcome(scenarioEvent)\n\n      if (possibleOutcome) {\n        outcome = possibleOutcome\n      }\n\n      \n    } else {\n      throw new Error(`Invalid criterial: ${JSON.stringify(criteria, null, 2)}`)\n    }\n\n    return outcome\n  }\n\n  /**\n   * \n   * @param path \n   * @param currentEvent \n   * @param accumulatedTags \n   */\n  private getPathEvent (tableName: string, accumulatedTags: Map<string, number>) {\n    const table = this.getTable(tableName)\n    const { roll, entry } = this.getEntry(table, accumulatedTags)\n\n    return {\n      roll,\n      tableName: table.name,\n      entry: entry.name,\n      tags: new Map(accumulatedTags)\n    }\n  }\n\n  /**\n   * \n   */\n  getEvent(tableName: string, entryName: string) {\n    return this.events.find(e => e.tableName === tableName && e.entryName === entryName)\n  }\n\n  /**\n   * \n   */\n  mergeOutcomes (event: ScenarioEvent, outcomes: Outcome[], addIfMissing = true) {\n    for (const outcome of event.outcomes) {\n      const existingOutcome = outcomes.find(o => outcome.tableName === o.tableName && outcome.likelihood === o.likelihood)\n\n      if (existingOutcome) {\n        // The outcome within the event already exists\n        for (const threshold of outcome.tagThresholds) {\n          existingOutcome.tagThresholds.forEach(t => {\n            if(t.name === threshold.name) {\n              // Add thresholds\n              t.minValue += threshold.minValue\n            }\n          })\n        }\n      } else {\n        // The outcome does not exist, add it\n        if (addIfMissing) {\n          outcomes.push(outcome)\n        }\n      }\n    }\n  }\n\n  /**\n   * Registers an Event to the scenario.\n   */\n  add(event: ScenarioEvent) {\n    const existingEvent = this.getEvent(event.tableName, event.entryName)\n\n    if (existingEvent !== undefined) {\n      // The event already exists\n      this.mergeOutcomes(event, existingEvent.outcomes)\n    } else {\n      // The event does not exist, add it\n      this.events.push(event)\n    }\n  }\n\n\n  /**\n   * Starts running the scenario from the first registered event.\n   * @returns Array of objects representing the path of entries chosen during scenario execution\n   */\n  run(accumulatedTags: Tags = new Map<string, number>(), currentEvent: ScenarioEvent | undefined = this.events[0], path: PathEvent[] = []): { path: PathEvent[], tags: Tags } {\n    if (this.events.length === 0) {\n      throw new Error('No events registered in the scenario.')\n    }\n\n    const pathEvent = this.getPathEvent(currentEvent.tableName, accumulatedTags)\n\n    path.push(pathEvent)\n\n    const nextEvent: ScenarioEvent | undefined = this.events.find((e) => pathEvent.tableName === e.tableName && pathEvent.entry === e.entryName)\n\n    if (nextEvent === undefined) {\n      // path.push(this.getPathEvent(currentEvent.tableName, accumulatedTags))\n      return { path, tags: accumulatedTags }\n    }\n\n    const outcome = this.getNextOutcome(nextEvent, {\n      byTags: accumulatedTags,\n      randomly: true\n    })\n\n    if (outcome) {\n      // There is an outcome\n      const nextEvents = this.events.filter((e) => e.tableName === outcome.tableName)\n      \n      if (nextEvents.length > 0) {\n        // Go through known scenario events involving this table\n        for (const nextEvent of nextEvents) {\n          this.run(accumulatedTags, nextEvent, path)\n        }\n      } else {\n        // We are done\n        path.push(this.getPathEvent(outcome.tableName, accumulatedTags))\n      }\n\n      \n    }\n\n    return {\n      path,\n      tags: accumulatedTags\n    }\n  }\n}\n", "import Outcome from './outcome'\n\n/**\n * Represents an Event, linking a specific Table and Entry name to possible Outcomes.\n */\nexport default class ScenarioEvent {\n  /** The name of the Table this event is tied to */\n  tableName: string\n  /** The name of the Entry in the Table */\n  entryName: string\n  /** Array of possible outcomes from this event */\n  outcomes: Outcome[]\n\n  /**\n   * @param tableName - Name of the Table this event is tied to\n   * @param entryName - Name of the Entry in the Table\n   * @param outcomes - Array of possible outcomes from this event\n   */\n  constructor(tableName: string, entryName: string, outcomes: Outcome[]) {\n    this.tableName = tableName\n    this.entryName = entryName\n    this.outcomes = outcomes\n  }\n}\n", "export interface TagThreshold {\n  name: string\n  minValue: number\n}\n\n/**\n * Represents an outcome from an event, pointing to the next table\n * with a given likelihood and optional tag thresholds.\n */\nexport default class Outcome {\n  /**\n   * Probability between 0 and 1 for this outcome.\n   */\n  likelihood: number\n\n  /**\n   * Name of the table to move to if this outcome is triggered.\n   */\n  tableName: string\n\n  /**\n   * Optional array of tag thresholds required to trigger this outcome.\n   * Each threshold includes a tag name and its minimum required value.\n   */\n  tagThresholds: TagThreshold[] = []\n\n  /**\n   * Creates a new Outcome instance.\n   * @param likelihood - Probability between 0 and 1 for this outcome.\n   * @param tableName - Name of the table to move to if triggered.\n   * @param tagThresholds - Optional array of tag thresholds to trigger this outcome.\n   */\n  constructor(likelihood: number, tableName: string, tagThresholds: TagThreshold[] = []) {\n    this.likelihood = likelihood\n    this.tableName = tableName\n    this.tagThresholds = tagThresholds\n  }\n}\n", "import Tag from './tag.ts'\n\n/**\n * Represents an entry within a Table, defined by a numeric range, name, and optional tags.\n */\nexport default class TableEntry {\n  start: number\n  end: number\n  name: string\n  tags: Tag[]\n\n  /**\n   * @param start - The starting number of the range (inclusive).\n   * @param end - The ending number of the range (inclusive).\n   * @param name - The name of the entry.\n   * @param tags - Optional array of tags associated with this entry.\n   */\n  constructor(start: number, end: number, name: string, tags: Tag[] = []) {\n    this.start = start\n    this.end = end\n    this.name = name\n    this.tags = tags\n  }\n\n  /**\n   * Determines whether a given value falls within this entry's range.\n   * @param value - The value to test against the entry's range.\n   * @returns True if value is within [start, end], else false.\n   */\n  matches(value: number): boolean {\n    return value >= this.start && value <= this.end\n  }\n}\n", "/**\n * Represents a tag with a name and a numerical value.\n */\nexport default class Tag {\n  name: string;\n  value: number;\n\n  /**\n   * @param name - The name of the tag.\n   * @param value - The numerical value associated with the tag.\n   */\n  constructor(name: string, value: number) {\n    this.name = name;\n    this.value = value;\n  }\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;ACOA,IAAqB,QAArB,MAA2B;AAAA,EACzB;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,MAAc,UAAwB,CAAC,GAAG;AACpD,SAAK,OAAO;AACZ,SAAK,UAAU;AAGf,yBAAa,cAAc,IAAI;AAAA,EACjC;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,SAAS,OAAyB;AAChC,SAAK,QAAQ,KAAK,KAAK;AAAA,EACzB;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,cAAsB;AACpB,QAAI,KAAK,QAAQ,WAAW,EAAG,QAAO;AACtC,WAAO,KAAK,IAAI,GAAG,KAAK,QAAQ,IAAI,WAAS,MAAM,GAAG,CAAC;AAAA,EACzD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,SAAS,OAAkC;AACzC,WAAO,KAAK,QAAQ,KAAK,WAAS,MAAM,QAAQ,KAAK,CAAC,KAAK;AAAA,EAC7D;AACF;;;AC3CA,IAAM,eAAgB,uBAAM;AAC1B,QAAM,SAA6B,oBAAI,IAAI;AAE3C,SAAO;AAAA;AAAA;AAAA;AAAA,IAIL,cAAc,OAAc;AAC1B,UAAI,EAAE,iBAAiB,QAAQ;AAC7B,cAAM,IAAI,MAAM,4CAA4C;AAAA,MAC9D;AAEA,UAAI,OAAO,IAAI,MAAM,IAAI,GAAG;AAC1B,cAAM,IAAI,MAAM,oBAAoB,MAAM,IAAI,0BAA0B;AAAA,MAC1E;AACA,aAAO,IAAI,MAAM,MAAM,KAAK;AAAA,IAC9B;AAAA;AAAA;AAAA;AAAA,IAKA,SAAS,MAAc;AACrB,aAAO,OAAO,IAAI,IAAI,KAAK;AAAA,IAC7B;AAAA;AAAA;AAAA;AAAA,IAKA,eAAe;AACb,aAAO,MAAM,KAAK,OAAO,OAAO,CAAC;AAAA,IACnC;AAAA;AAAA;AAAA;AAAA;AAAA,IAMA,WAAW;AACT,aAAO,MAAM;AAAA,IACf;AAAA,EACF;AACF,GAAG;AAEH,IAAO,uBAAQ;;;ACzCf,IAAqB,kBAArB,MAAqC;AAAA,EAC3B;AAAA,EAER,YAAY,MAAwB;AAClC,QAAI,SAAS,QAAW;AAEtB,YAAM,QAAQ,IAAI,YAAY,CAAC;AAC/B,aAAO,gBAAgB,KAAK;AAC5B,WAAK,QAAQ,MAAM,CAAC;AAAA,IACtB,WAAW,OAAO,SAAS,UAAU;AACnC,UAAI,IAAI,aAAa,KAAK;AAC1B,eAAS,IAAI,GAAG,IAAI,KAAK,QAAQ,KAAK;AACpC,YAAI,KAAK,KAAK,IAAI,KAAK,WAAW,CAAC,GAAG,UAAU;AAChD,YAAK,KAAK,KAAO,MAAM;AAAA,MACzB;AACA,WAAK,QAAQ,MAAM;AAAA,IACrB,OAAO;AACL,WAAK,QAAQ,SAAS;AAAA,IACxB;AAAA,EACF;AAAA;AAAA,EAGA,SAAiB;AACf,SAAK,SAAS;AACd,QAAI,IAAI,KAAK;AACb,QAAI,KAAK,KAAK,IAAK,MAAM,IAAK,IAAI,CAAC;AACnC,SAAK,IAAI,KAAK,KAAK,IAAK,MAAM,GAAI,IAAI,EAAE;AACxC,aAAS,IAAK,MAAM,QAAS,KAAK;AAAA,EACpC;AAAA;AAAA,EAGA,UAAU,KAAa,KAAqB;AAC1C,WAAO,KAAK,MAAM,KAAK,OAAO,KAAK,MAAM,IAAI,IAAI;AAAA,EACnD;AACF;;;ACtBA,IAAqB,WAArB,MAA8B;AAAA;AAAA,EAE5B;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA;AAAA;AAAA,EAKA,YAAY,MAAc,MAAuB,IAAI,gBAAgB,GAAG;AACtE,SAAK,OAAO;AACZ,SAAK,MAAM;AACX,SAAK,SAAS,CAAC;AAAA,EACjB;AAAA;AAAA;AAAA;AAAA,EAKQ,SAAU,WAAoB;AACpC,UAAM,QAAQ,qBAAa,SAAS,SAAS;AAE7C,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,MAAM,UAAU,SAAS,cAAc;AAAA,IACnD;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA,EAKQ,SAAU,OAAc,iBAAsC;AACpE,UAAM,OAAO,KAAK,IAAI,UAAU,GAAG,MAAM,YAAY,CAAC,IAAI;AAC1D,UAAM,QAAQ,MAAM,SAAS,IAAI;AAEjC,QAAI,CAAC,OAAO;AACV,YAAM,IAAI,MAAM,2BAA2B,IAAI,cAAc,MAAM,IAAI,IAAI;AAAA,IAC7E;AAEA,QAAI,MAAM,QAAQ,MAAM,KAAK,SAAS,GAAG;AACvC,iBAAW,OAAO,MAAM,MAAM;AAC5B,wBAAgB,IAAI,IAAI,OAAO,gBAAgB,IAAI,IAAI,IAAI,KAAK,KAAK,IAAI,KAAK;AAAA,MAChF;AAAA,IACF;AAEA,WAAO;AAAA,MACL;AAAA,MAAM;AAAA,IACR;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,iBAAiB,eAA8B,WAAsB,cAAc,UAA4B;AACrH,UAAM,aAAmE,CAAC;AAC1E,QAAI,MAAM;AAEV,eAAWA,YAAW,UAAU;AAC9B,aAAOA,SAAQ;AACf,iBAAW,KAAK,EAAE,SAAAA,UAAS,sBAAsB,IAAI,CAAC;AAAA,IACxD;AAEA,UAAM,OAAO,KAAK,IAAI,OAAO,IAAI;AACjC,UAAM,UAAU,WAAW,KAAK,CAAC,EAAE,qBAAqB,MAAM,QAAQ,oBAAoB,GAAG;AAE7F,QAAI,CAAC,SAAS;AACZ,aAAO;AAAA,IACT;AAEA,WAAO;AAAA,EACT;AAAA,EAEQ,oBAAqB,eAA8B,iBAAuB;AAChF,UAAM,gBAAgB,cAAc,SAAS,OAAO,aAAW;AAC7D,aAAO,QAAQ,iBAAiB,QAAQ,cAAc,SAAS;AAAA,IACjE,CAAC,EAAE,SAAS;AAEZ,UAAM,mBAA8B,cAAc,SAAS,OAAO,aAAW;AAC3E,UAAI,eAAe;AAEjB,YAAI,CAAC,QAAQ,iBAAiB,QAAQ,cAAc,WAAW,GAAG;AAChE,iBAAO;AAAA,QACT;AAEA,eAAO,QAAQ,cAAc,MAAM,CAAC,EAAE,MAAM,SAAS,MAAM;AACzD,kBAAQ,gBAAgB,IAAI,IAAI,KAAK,MAAM;AAAA,QAC7C,CAAC;AAAA,MACH,OAAO;AAEL,eAAO;AAAA,MACT;AAAA,IACF,CAAC;AAED,QAAI,iBAAiB,iBAAiB,WAAW,GAAG;AAElD,aAAO,cAAc,SAAS,OAAO,aAAW;AAC9C,eAAO,QAAQ,iBAAiB,QAAQ,cAAc,WAAW;AAAA,MACnE,CAAC;AAAA,IACH,OAAO;AAEL,aAAO;AAAA,IACT;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKQ,eAAe,eAA8B,UAA4F;AAC/I,QAAI;AAEJ,QAAI,aAAa,QAAW;AAC1B,YAAM,kBAAkB,SAAS,UAAU,oBAAI,IAAoB;AACnE,YAAM,mBAAmB,KAAK,oBAAoB,eAAe,eAAe;AAEhF,UAAI,gBAAgB,OAAO,GAAG;AAI5B,cAAM,kBAAkB,KAAK,iBAAiB,eAAe,gBAAgB;AAE7E,YAAI,iBAAiB;AACnB,oBAAU;AAAA,QACZ;AAAA,MACF;AAEA,UAAI,YAAY,UAAa,SAAS,UAAU;AAI9C,cAAM,kBAAkB,KAAK,iBAAiB,eAAe,gBAAgB;AAE7E,YAAI,iBAAiB;AACnB,oBAAU;AAAA,QACZ;AAAA,MACF;AAEA,UAAI,YAAY,UAAa,SAAS,aAAa;AAIjD,cAAM,kBAAkB,cAAc,SAAS,KAAK,CAAC,MAAM,EAAE,cAAc,SAAS,WAAW;AAE/F,YAAI,iBAAiB;AACnB,oBAAU;AAAA,QACZ;AAAA,MACF;AAAA,IACF,WAAW,aAAa,QAAW;AAIjC,YAAM,kBAAkB,KAAK,iBAAiB,aAAa;AAE3D,UAAI,iBAAiB;AACnB,kBAAU;AAAA,MACZ;AAAA,IAGF,OAAO;AACL,YAAM,IAAI,MAAM,sBAAsB,KAAK,UAAU,UAAU,MAAM,CAAC,CAAC,EAAE;AAAA,IAC3E;AAEA,WAAO;AAAA,EACT;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQQ,aAAc,WAAmB,iBAAsC;AAC7E,UAAM,QAAQ,KAAK,SAAS,SAAS;AACrC,UAAM,EAAE,MAAM,MAAM,IAAI,KAAK,SAAS,OAAO,eAAe;AAE5D,WAAO;AAAA,MACL;AAAA,MACA,WAAW,MAAM;AAAA,MACjB,OAAO,MAAM;AAAA,MACb,MAAM,IAAI,IAAI,eAAe;AAAA,IAC/B;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,SAAS,WAAmB,WAAmB;AAC7C,WAAO,KAAK,OAAO,KAAK,OAAK,EAAE,cAAc,aAAa,EAAE,cAAc,SAAS;AAAA,EACrF;AAAA;AAAA;AAAA;AAAA,EAKA,cAAe,OAAsB,UAAqB,eAAe,MAAM;AAC7E,eAAW,WAAW,MAAM,UAAU;AACpC,YAAM,kBAAkB,SAAS,KAAK,OAAK,QAAQ,cAAc,EAAE,aAAa,QAAQ,eAAe,EAAE,UAAU;AAEnH,UAAI,iBAAiB;AAEnB,mBAAW,aAAa,QAAQ,eAAe;AAC7C,0BAAgB,cAAc,QAAQ,OAAK;AACzC,gBAAG,EAAE,SAAS,UAAU,MAAM;AAE5B,gBAAE,YAAY,UAAU;AAAA,YAC1B;AAAA,UACF,CAAC;AAAA,QACH;AAAA,MACF,OAAO;AAEL,YAAI,cAAc;AAChB,mBAAS,KAAK,OAAO;AAAA,QACvB;AAAA,MACF;AAAA,IACF;AAAA,EACF;AAAA;AAAA;AAAA;AAAA,EAKA,IAAI,OAAsB;AACxB,UAAM,gBAAgB,KAAK,SAAS,MAAM,WAAW,MAAM,SAAS;AAEpE,QAAI,kBAAkB,QAAW;AAE/B,WAAK,cAAc,OAAO,cAAc,QAAQ;AAAA,IAClD,OAAO;AAEL,WAAK,OAAO,KAAK,KAAK;AAAA,IACxB;AAAA,EACF;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,IAAI,kBAAwB,oBAAI,IAAoB,GAAG,eAA0C,KAAK,OAAO,CAAC,GAAG,OAAoB,CAAC,GAAsC;AAC1K,QAAI,KAAK,OAAO,WAAW,GAAG;AAC5B,YAAM,IAAI,MAAM,uCAAuC;AAAA,IACzD;AAEA,UAAM,YAAY,KAAK,aAAa,aAAa,WAAW,eAAe;AAE3E,SAAK,KAAK,SAAS;AAEnB,UAAM,YAAuC,KAAK,OAAO,KAAK,CAAC,MAAM,UAAU,cAAc,EAAE,aAAa,UAAU,UAAU,EAAE,SAAS;AAE3I,QAAI,cAAc,QAAW;AAE3B,aAAO,EAAE,MAAM,MAAM,gBAAgB;AAAA,IACvC;AAEA,UAAM,UAAU,KAAK,eAAe,WAAW;AAAA,MAC7C,QAAQ;AAAA,MACR,UAAU;AAAA,IACZ,CAAC;AAED,QAAI,SAAS;AAEX,YAAM,aAAa,KAAK,OAAO,OAAO,CAAC,MAAM,EAAE,cAAc,QAAQ,SAAS;AAE9E,UAAI,WAAW,SAAS,GAAG;AAEzB,mBAAWC,cAAa,YAAY;AAClC,eAAK,IAAI,iBAAiBA,YAAW,IAAI;AAAA,QAC3C;AAAA,MACF,OAAO;AAEL,aAAK,KAAK,KAAK,aAAa,QAAQ,WAAW,eAAe,CAAC;AAAA,MACjE;AAAA,IAGF;AAEA,WAAO;AAAA,MACL;AAAA,MACA,MAAM;AAAA,IACR;AAAA,EACF;AACF;;;ACtSA,IAAqB,gBAArB,MAAmC;AAAA;AAAA,EAEjC;AAAA;AAAA,EAEA;AAAA;AAAA,EAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,YAAY,WAAmB,WAAmB,UAAqB;AACrE,SAAK,YAAY;AACjB,SAAK,YAAY;AACjB,SAAK,WAAW;AAAA,EAClB;AACF;;;ACdA,IAAqB,UAArB,MAA6B;AAAA;AAAA;AAAA;AAAA,EAI3B;AAAA;AAAA;AAAA;AAAA,EAKA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,gBAAgC,CAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQjC,YAAY,YAAoB,WAAmB,gBAAgC,CAAC,GAAG;AACrF,SAAK,aAAa;AAClB,SAAK,YAAY;AACjB,SAAK,gBAAgB;AAAA,EACvB;AACF;;;AChCA,IAAqB,aAArB,MAAgC;AAAA,EAC9B;AAAA,EACA;AAAA,EACA;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAQA,YAAY,OAAe,KAAa,MAAc,OAAc,CAAC,GAAG;AACtE,SAAK,QAAQ;AACb,SAAK,MAAM;AACX,SAAK,OAAO;AACZ,SAAK,OAAO;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAOA,QAAQ,OAAwB;AAC9B,WAAO,SAAS,KAAK,SAAS,SAAS,KAAK;AAAA,EAC9C;AACF;;;AC7BA,IAAqB,MAArB,MAAyB;AAAA,EACvB;AAAA,EACA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,YAAY,MAAc,OAAe;AACvC,SAAK,OAAO;AACZ,SAAK,QAAQ;AAAA,EACf;AACF;",
  "names": ["outcome", "nextEvent"]
}
