{
  "version": 3,
  "sources": ["../src/index.ts", "../src/table.ts", "../src/tableManager.ts", "../src/scenarioEvent.ts", "../src/rng.ts", "../src/tag.ts", "../src/journey.ts", "../src/scenario.ts", "../src/outcome.ts", "../src/tableEntry.ts"],
  "sourcesContent": ["// Main exports\nexport { default as Scenario } from './scenario'\nexport { default as ScenarioEvent } from './scenarioEvent'\nexport { default as Outcome } from './outcome'\nexport { default as Table } from './table'\nexport { default as TableEntry } from './tableEntry'\nexport { default as TableManager } from './tableManager'\nexport { default as Tag } from './tag'\nexport { default as SimpleSeededRNG } from './rng'\nexport { default as Journey } from './journey'\n", "import TableEntry from './tableEntry'\nimport TableManager from './tableManager'\n\n/**\n * Represents a table of entries that can be queried based on numeric input.\n * Automatically registers itself with the TableManager singleton.\n */\nexport default class Table {\n  name: string\n  entries: TableEntry[]\n\n  /**\n   * @param name - The unique name of the table.\n   * @param entries - Optional array of entries to initialize the table with.\n   */\n  constructor(name: string, entries: TableEntry[] = []) {\n    this.name = name\n    this.entries = entries\n\n    // Automatically register with TableManager\n    TableManager.registerTable(this)\n  }\n\n  /**\n   * Adds a new entry to the table.\n   * @param entry - The entry to add.\n   */\n  addEntry(entry: TableEntry): void {\n    this.entries.push(entry)\n  }\n\n  /**\n   * Gets the highest `end` value across all entries in the table.\n   * Useful for determining the max rollable number.\n   * @returns The maximum end value or 0 if the table is empty.\n   */\n  getMaxValue(): number {\n    if (this.entries.length === 0) return 0\n    return Math.max(...this.entries.map(entry => entry.end))\n  }\n\n  /**\n   * Retrieves the entry that matches a given numeric input.\n   * @param value - The number to look up.\n   * @returns The matching entry, or null if no match is found.\n   */\n  getEntry(value: number): TableEntry | null {\n    return this.entries.find(entry => entry.matches(value)) ?? null\n  }\n}\n", "import Table from './table'\n\n/**\n * Singleton manager that keeps track of all registered tables.\n * Tables are registered automatically upon instantiation.\n */\nconst TableManager = (() => {\n  const tables: Map<string, Table> = new Map()\n\n  return {\n    /**\n     * Registers a new table by name.\n     */\n    registerTable(table: Table) {\n      if (!(table instanceof Table)) {\n        throw new Error(\"Only instances of Table can be registered.\")\n      }\n      \n      if (tables.has(table.name)) {\n        throw new Error(`Table with name \"${table.name}\" is already registered.`)\n      }\n      tables.set(table.name, table)\n    },\n\n    /**\n     * Retrieves a registered table by name.\n     */\n    getTable(name: string) {\n      return tables.get(name) || null;\n    },\n\n    /**\n     * Retrieves all registered tables.\n     */\n    getAllTables() {\n      return Array.from(tables.values());\n    },\n\n    /**\n     * Clears all registered tables.\n     * Useful for resetting state between tests.\n     */\n    clearAll() {\n      tables.clear()\n    }\n  }\n})()\n\nexport default TableManager\n", "import Outcome from './outcome'\n\n/**\n * Represents an Event, linking a specific Table and Entry name to possible Outcomes.\n */\nexport default class ScenarioEvent {\n  /** The name of the Table this event is tied to */\n  tableName: string\n  /** The name of the Entry in the Table */\n  entryName: string\n  /** Array of possible outcomes from this event */\n  outcomes: Outcome[]\n\n  /**\n   * @param tableName - Name of the Table this event is tied to\n   * @param entryName - Name of the Entry in the Table\n   * @param outcomes - Array of possible outcomes from this event\n   */\n  constructor(tableName: string, entryName: string, outcomes: Outcome[]) {\n    this.tableName = tableName\n    this.entryName = entryName\n    this.outcomes = outcomes\n  }\n}\n", "/**\n * SimpleSeededRNG\n *\n * Lightweight deterministic RNG for browsers.\n * Based on Mulberry32: fast, good-quality random stream from a seed.\n * If no seed is provided, uses crypto.getRandomValues for unseeded randomness.\n */\nexport default class SimpleSeededRNG {\n  private state: number\n\n  constructor(seed?: number | string) {\n    if (seed === undefined) {\n      // Use cryptographically secure randomness\n      const array = new Uint32Array(1)\n      crypto.getRandomValues(array)\n      this.state = array[0]\n    } else if (typeof seed === 'string') {\n      let h = 1779033703 ^ seed.length\n      for (let i = 0; i < seed.length; i++) {\n        h = Math.imul(h ^ seed.charCodeAt(i), 3432918353)\n        h = (h << 13) | (h >>> 19)\n      }\n      this.state = h >>> 0\n    } else {\n      this.state = seed >>> 0\n    }\n  }\n\n  /** Returns a float between 0 (inclusive) and 1 (exclusive). */\n  random(): number {\n    this.state += 0x6D2B79F5\n    let t = this.state\n    t = Math.imul(t ^ (t >>> 15), t | 1)\n    t ^= t + Math.imul(t ^ (t >>> 7), t | 61)\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296\n  }\n\n  /** Returns an integer between min (inclusive) and max (exclusive). */\n  randomInt(min: number, max: number): number {\n    return Math.floor(this.random() * (max - min)) + min\n  }\n}\n", "import Journey, { type JourneyTags } from './journey'\n\nexport type TagModifier = (journey: Journey) => Tag[]\n\n/**\n * Represents a tag with a name and a numerical value.\n */\nexport default class Tag {\n  name: string;\n  value: number;\n\n  /**\n   * @param name - The name of the tag.\n   * @param value - The numerical value associated with the tag.\n   */\n  constructor(name: string, value: number) {\n    this.name = name;\n    this.value = value;\n  }\n\n  /**\n   * \n   */\n  static unwrap(journey: Journey, tags: (TagModifier | Tag)[]) {\n    const result: Tag[] = []\n\n    for(const tag of tags) {\n      if (tag instanceof Tag) {\n        result.push(tag)\n      } else {\n        tag(journey).forEach(tag => result.push(tag))\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * \n   */\n  apply (journey: Journey, tags: (TagModifier | Tag)[]) {\n    const target = Tag.unwrap(journey, tags)\n\n    for (const tag of target) {\n      if(tag.name === this.name) {\n        tag.value += this.value\n      }\n    }\n\n    return target\n  }\n\n  /**\n   * \n   */\n  update (tags: Tag[]) {\n    let didUpdate = false\n\n    tags.forEach(t => {\n      if(t.name === this.name) {\n        this.value += t.value\n        didUpdate = true\n      }\n    })\n\n    return didUpdate\n  }\n}\n", "import Tag, { TagModifier } from './tag'\nimport TableEntry from './tableEntry'\n\nexport type JourneyTags = Map<string, number>\n\nexport type PathEvent = {\n  tableName: string\n  entry: string\n  description: string\n  roll: number\n  tags: Map<string, number>\n}\n\n/**\n * \n */\nexport default class Journey {\n  tags: JourneyTags\n  path: PathEvent[] \n\n  constructor (tags: JourneyTags = new Map(), path: PathEvent[] = []) {\n    this.tags = tags\n    this.path = path\n  }\n\n  /**\n   * \n   */\n  getPaths(criteria: { tableName?: string, entry?: string, rollEquals?: number, rollLessThan?: number, rollGreaterThan?: number } = {}) {\n    const results = this.path.filter(path => {\n      let found = false\n      if(criteria.tableName !== undefined) {\n        found = criteria.tableName === path.tableName\n      }\n\n      if(criteria.entry !== undefined) {\n        found = criteria.entry === path.entry\n      }\n\n      if(criteria.rollEquals !== undefined) {\n        found = criteria.rollEquals === path.roll\n      }\n\n      if(criteria.rollLessThan !== undefined) {\n        found = criteria.rollLessThan < path.roll\n      }\n\n      if(criteria.rollGreaterThan !== undefined) {\n        found = criteria.rollGreaterThan > path.roll\n      }\n\n      return found\n    })\n\n    return results\n  }\n\n  /**\n   * \n   */\n  hasPath (criteria: { tableName?: string, entry?: string, rollEquals?: number, rollLessThan?: number, rollGreaterThan?: number } = {}, count: number = 0) {\n    const result = this.getPaths(criteria)\n\n    return result.length > count\n  }\n\n  /**\n   * \n   */\n  hasTag(name: string, criteria: { equals?: number, lessThan?: number, greaterThan?: number } = {}) {\n    const value = this.tags.get(name)\n\n    if (value === undefined) {\n      return false\n    }\n\n    if (criteria.equals !== undefined) {\n      return value === criteria.equals\n    } else if (criteria.lessThan !== undefined) {\n      return value < criteria.lessThan\n    } else if (criteria.greaterThan !== undefined) {\n      return value > criteria.greaterThan\n    } else {\n      return true\n    }\n  }\n\n  /**\n   *\n   */\n  hasTags () {\n    return this.tags.size > 0\n  }\n\n  /**\n   * \n   */\n  addPathEvent (roll: number, tableName: string, entry: TableEntry) {\n    this.accumulate(entry.tags)\n\n    const pathEvent: PathEvent = {\n      roll,\n      tableName,\n      entry: entry.name,\n      description: entry.description,\n      tags: new Map(this.tags)\n    }\n\n    this.path.push(pathEvent)\n\n    return pathEvent\n  }\n\n  /**\n   * \n   */\n  accumulate (tags: (TagModifier | Tag)[]) {\n    const target = Tag.unwrap(this, tags)\n\n    for (const tag of target) {\n      const value = this.tags.get(tag.name) || 0\n      this.tags.set(tag.name, value + tag.value)\n    }\n\n    return target\n  }\n\n  /**\n   * \n   */\n  isActivated (tags: (TagModifier | Tag)[]) {\n    return tags.every((tag) => {\n      if (tag instanceof Tag) {\n        // Dealing with a tag\n        return (this.tags.get(tag.name) || 0) >= tag.value\n      } else {\n        // Dealing with a TagModifier function\n        return this.isActivated(tag(this))\n      }\n      \n    })\n  }\n}", "import Tag from './tag'\nimport TableManager from './tableManager'\nimport ScenarioEvent from './scenarioEvent'\nimport Outcome from './outcome'\nimport SimpleSeededRNG from './rng'\nimport Table from './table'\nimport Journey, { type JourneyTags, type PathEvent } from './journey'\n\n/**\n * Represents a Scenario which chains table entries through Events and Outcomes.\n */\nexport default class Scenario {\n  /** Name of the scenario */\n  name: string\n  /** RNG providing random() and randomInt(max) */\n  rng: SimpleSeededRNG\n  /** Registered events in this scenario */\n  events: ScenarioEvent[]\n  /** The journey taken through this scenario */\n  journey: Journey\n  /** Outputs a journey */\n  debug: string = ''\n\n  /**\n   * Constructor\n   */\n  constructor(name: string, rng: SimpleSeededRNG = new SimpleSeededRNG(), journey: Journey = new Journey()) {\n    this.name = name\n    this.rng = rng\n    this.events = []\n    this.journey = journey\n  }\n\n  /**\n   * Gets a table\n   */\n  private getTable (tableName: string)  {\n    const table = TableManager.getTable(tableName)\n\n    if (!table) {\n      throw new Error(`Table \"${tableName}\" not found.`)\n    }\n\n    return table\n  }\n\n  /**\n   * Gets a Table Entry\n   */\n  private getEntry (table: Table, journey: Journey = this.journey) {\n    const roll = this.rng.randomInt(0, table.getMaxValue()) + 1\n    const entry = table.getEntry(roll)\n\n    if (!entry) {\n      throw new Error(`No entry found for roll ${roll} in table \"${table.name}\".`)\n    }\n\n    return {\n      roll, entry\n    }\n  }\n\n  /**\n   * Gets a random Outcome from a Scenario Event\n   */\n  private getRandomOutcome(scenarioEvent: ScenarioEvent, outcomes: Outcome[] = scenarioEvent.outcomes): Outcome | false  {\n    const cumulative: { outcome: Outcome; cumulativeLikelihood: number }[] = []\n    let sum = 0\n\n    for (const outcome of outcomes) {\n      sum += outcome.likelihood\n      cumulative.push({ outcome, cumulativeLikelihood: sum })\n    }\n\n    const rand = this.rng.random() * sum\n    const outcome = cumulative.find(({ cumulativeLikelihood }) => rand <= cumulativeLikelihood)?.outcome\n\n    if (!outcome) {\n      return false\n    }\n\n    return outcome\n  }\n\n  /**\n   * Gets possible outcomes based on how the Journey and the Scenario Event intersect\n   */\n  private getPossibleOutcomes (scenarioEvent: ScenarioEvent, journey: Journey = this.journey) {\n    const hasThresholds = scenarioEvent.outcomes.filter(outcome => {\n      return outcome.tagThresholds && outcome.tagThresholds.length > 0\n    }).length > 0\n\n    const possibleOutcomes: Outcome[] = scenarioEvent.outcomes.filter(outcome => {\n      if (hasThresholds) {\n        // This scenario event has thresholds, use them\n        if (!outcome.tagThresholds || outcome.tagThresholds.length === 0) {\n          return false\n        }\n\n        return journey.isActivated(outcome.tagThresholds)\n      } else {\n        // This scenario event has no thresholds, use them\n        return outcome\n      }\n    })\n\n    if (hasThresholds && possibleOutcomes.length === 0) {\n      // All threshold checks have failed, use all non-thresholded outcomesinstead\n      return scenarioEvent.outcomes.filter(outcome => {\n        return outcome.tagThresholds && outcome.tagThresholds.length === 0\n      })\n    } else {\n      // Return all possible outcomes\n      return possibleOutcomes\n    }\n  }\n\n  /**\n   * Gets the next outcome of a Scenario Event\n   */\n  private getNextOutcome(scenarioEvent: ScenarioEvent, criteria?: { byTableName?: string, randomly?: boolean, byTags?: JourneyTags}, journey: Journey = this.journey): Outcome | undefined {\n    let outcome: Outcome | undefined\n\n    if (criteria !== undefined) {\n      const journey = new Journey(criteria.byTags ?? new Map<string, number>())\n      const possibleOutcomes = this.getPossibleOutcomes(scenarioEvent, journey)\n\n      if (possibleOutcomes.length === 0) {\n        this.echo('No possible outcomes!')\n        return\n      }\n\n      if (journey.hasTags() || criteria.randomly) {\n        /**\n         * Find outcome by tags\n         **/\n        this.echo(`Getting 1 of ${possibleOutcomes.length} random valid outcome...`)\n\n        const possibleOutcome = this.getRandomOutcome(scenarioEvent, possibleOutcomes)\n\n        if (possibleOutcome) {\n          outcome = possibleOutcome\n        }\n      }     \n\n      if (outcome === undefined && criteria.byTableName) {\n        /**\n         * Find outcome by table name\n         */\n        this.echo('Getting outcome by table name...')\n        const possibleOutcome = scenarioEvent.outcomes.find((o) => o.tableName === criteria.byTableName)\n\n        if (possibleOutcome) {\n          outcome = possibleOutcome\n        }\n      }\n    } else if (criteria === undefined) {\n      /**\n       * Find outcome by probability\n       */\n      this.echo('Getting random outcome...')\n      const possibleOutcome = this.getRandomOutcome(scenarioEvent)\n\n      if (possibleOutcome) {\n        outcome = possibleOutcome\n      }\n\n      \n    } else {\n      throw new Error(`Invalid criterial: ${JSON.stringify(criteria, null, 2)}`)\n    }\n\n    return outcome\n  }\n\n  /**\n   * Adds a Path Event to the Journey\n   */\n  private addPathEvent (tableName: string, journey: Journey = this.journey) {\n    const table = this.getTable(tableName)\n    const { roll, entry } = this.getEntry(table, journey)\n    this.echo(`Adding \"${tableName}/${entry.name}\" to path`)\n    return journey.addPathEvent(roll, tableName, entry)\n  }\n\n  /**\n   * Gets an event by Table Entry\n   */\n  getEvent(tableName: string, entryName: string) {\n    return this.events.find(e => e.tableName === tableName && e.entryName === entryName)\n  }\n\n  /**\n   * Merges outcomes into a Scenario Event\n   */\n  mergeOutcomes (newEvent: ScenarioEvent, existingOutcomes: Outcome[], addIfMissing = true) {\n    for (const outcome of newEvent.outcomes) {\n      const existingOutcome = existingOutcomes.find(\n        o => outcome.tableName === o.tableName && outcome.likelihood === o.likelihood\n      )\n\n      if (existingOutcome) {\n        for (const threshold of outcome.tagThresholds) {\n          existingOutcome.tagThresholds.push(threshold)\n        }\n      } else {\n        // The outcome does not exist, add it\n        if (addIfMissing) {\n          existingOutcomes.push(outcome)\n        }\n      }\n    }\n  }\n\n  /**\n   * Registers an Event to the scenario.\n   */\n  add(tableName: string, entryName: string, outcomes: Outcome[]) {\n    const event = new ScenarioEvent(tableName, entryName, outcomes)\n    const existingEvent = this.getEvent(event.tableName, event.entryName)\n\n    if (existingEvent !== undefined) {\n      // The event already exists\n      this.mergeOutcomes(event, existingEvent.outcomes)\n    } else {\n      // The event does not exist, add it\n      this.events.push(event)\n    }\n  }\n\n  echo (message: string, object: Object | string = '') {\n    const objMsg = object !== '' ? JSON.stringify(object, null, 2) : ''\n    this.debug !== '' && console.log(this.debug, message, objMsg)\n  }\n\n  /**\n   * Starts running the scenario from the first registered event.\n   */\n  run(journey: Journey = this.journey, currentEvent: ScenarioEvent | undefined = this.events[0]): Journey {\n    if (this.events.length === 0) {\n      throw new Error('No events registered in the scenario.')\n    }\n\n    this.echo(`Adding path for ${currentEvent.tableName}`)\n\n    const pathEvent = this.addPathEvent(currentEvent.tableName, journey)\n\n    this.echo(`Searching for \"${pathEvent.tableName}/${pathEvent.entry}\" event...`)\n\n    const nextEvent = this.events.find((e) =>\n      pathEvent.tableName === e.tableName && pathEvent.entry === e.entryName\n    )\n\n    if (nextEvent === undefined) {\n      this.echo('Could not find it, bailing')\n      return journey\n    }\n\n    this.echo('Found it!')\n    this.echo('Searching for the next outcome with tags:', journey.tags)\n\n    const outcome = this.getNextOutcome(nextEvent, {\n      byTags: journey.tags,\n      randomly: true\n    })\n\n    if (outcome) {\n      // There is an outcome\n      this.echo('There is a next outcome')\n      const nextEvents = this.events.filter((e) => e.tableName === outcome.tableName)\n      \n      if (nextEvents.length > 0) {\n        this.echo(`Running ${nextEvents.length} events...`)\n        // Go through known scenario events involving this table\n        for (const nextEvent of nextEvents) {\n          this.echo('Running event:', nextEvent)\n\n          if(this.debug !== '') {\n            this.debug += '.'\n          }\n\n          journey = this.run(journey, nextEvent)\n        }\n      } else {\n        // We are done\n        this.echo(`There are no more events, adding ${outcome.tableName} to path`)\n        this.addPathEvent(outcome.tableName, journey)\n      }\n    }\n\n    this.echo(`Returning from event`)\n    this.debug = this.debug.slice(0, -1)\n    return journey\n  }\n}\n", "import Tag, { TagModifier } from './tag'\n\n/**\n * Represents an outcome from an event, pointing to the next table\n * with a given likelihood and optional tag thresholds.\n */\nexport default class Outcome {\n  /**\n   * Probability between 0 and 1 for this outcome.\n   */\n  likelihood: number\n\n  /**\n   * Name of the table to move to if this outcome is triggered.\n   */\n  tableName: string\n\n  /**\n   * Optional array of tag thresholds required to trigger this outcome.\n   * Each threshold includes a tag name and its minimum required value.\n   */\n  tagThresholds: (TagModifier | Tag)[]\n\n  /**\n   * Creates a new Outcome instance.\n   * @param likelihood - Probability between 0 and 1 for this outcome.\n   * @param tableName - Name of the table to move to if triggered.\n   * @param tagThresholds - Optional array of tag thresholds to trigger this outcome.\n   */\n  constructor(likelihood: number, tableName: string, tagThresholds: (TagModifier | Tag)[] = []) {\n    this.likelihood = likelihood\n    this.tableName = tableName\n    this.tagThresholds = tagThresholds\n  }\n}\n", "import Tag, { TagModifier } from './tag.ts'\n\n/**\n * Represents an entry within a Table, defined by a numeric range, name, and optional tags.\n */\nexport default class TableEntry {\n  start: number\n  end: number\n  name: string\n  description: string\n  tags: (TagModifier | Tag)[]\n\n  /**\n   * @param start - The starting number of the range (inclusive).\n   * @param end - The ending number of the range (inclusive).\n   * @param name - The name of the entry.\n   * @param tags - Optional array of tags associated with this entry.\n   */\n  constructor(start: number, end: number, name: string, description: string = name, tags: (TagModifier | Tag)[] = []) {\n    this.start = start\n    this.end = end\n    this.name = name\n    this.description = description\n    this.tags = tags\n  }\n\n  /**\n   * Determines whether a given value falls within this entry's range.\n   * @param value - The value to test against the entry's range.\n   * @returns True if value is within [start, end], else false.\n   */\n  matches(value: number): boolean {\n    return value >= this.start && value <= this.end\n  }\n}\n"],
  "mappings": "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",
  "names": ["tag", "outcome", "journey", "nextEvent"]
}
