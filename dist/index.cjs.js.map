{
  "version": 3,
  "sources": ["../src/index.ts", "../src/table.ts", "../src/tableManager.ts", "../src/scenario.ts", "../src/scenarioEvent.ts", "../src/outcome.ts", "../src/tableEntry.ts", "../src/tag.ts", "../src/rng.ts"],
  "sourcesContent": ["// Main exports\nexport { default as Scenario } from './scenario'\nexport { default as ScenarioEvent } from './scenarioEvent'\nexport { default as Outcome } from './outcome'\nexport { default as Table } from './table'\nexport { default as TableEntry } from './tableEntry'\nexport { default as TableManager } from './tableManager'\nexport { default as Tag } from './tag'\nexport { default as RNG } from './rng'\n", "import TableEntry from './tableEntry'\nimport TableManager from './tableManager'\n\n/**\n * Represents a table of entries that can be queried based on numeric input.\n * Automatically registers itself with the TableManager singleton.\n */\nexport default class Table {\n  name: string\n  entries: TableEntry[]\n\n  /**\n   * @param name - The unique name of the table.\n   * @param entries - Optional array of entries to initialize the table with.\n   */\n  constructor(name: string, entries: TableEntry[] = []) {\n    this.name = name\n    this.entries = entries\n\n    // Automatically register with TableManager\n    TableManager.registerTable(this)\n  }\n\n  /**\n   * Adds a new entry to the table.\n   * @param entry - The entry to add.\n   */\n  addEntry(entry: TableEntry): void {\n    this.entries.push(entry)\n  }\n\n  /**\n   * Gets the highest `end` value across all entries in the table.\n   * Useful for determining the max rollable number.\n   * @returns The maximum end value or 0 if the table is empty.\n   */\n  getMaxValue(): number {\n    if (this.entries.length === 0) return 0\n    return Math.max(...this.entries.map(entry => entry.end))\n  }\n\n  /**\n   * Retrieves the entry that matches a given numeric input.\n   * @param value - The number to look up.\n   * @returns The matching entry, or null if no match is found.\n   */\n  getEntry(value: number): TableEntry | null {\n    return this.entries.find(entry => entry.matches(value)) ?? null\n  }\n}\n", "import Table from './table'\n\n/**\n * Singleton manager that keeps track of all registered tables.\n * Tables are registered automatically upon instantiation.\n */\nconst TableManager = (() => {\n  const tables: Map<string, Table> = new Map()\n\n  return {\n    /**\n     * Registers a new table by name.\n     */\n    registerTable(table: Table) {\n      if (!(table instanceof Table)) {\n        throw new Error(\"Only instances of Table can be registered.\")\n      }\n      \n      if (tables.has(table.name)) {\n        throw new Error(`Table with name \"${table.name}\" is already registered.`)\n      }\n      tables.set(table.name, table)\n    },\n\n    /**\n     * Retrieves a registered table by name.\n     */\n    getTable(name: string) {\n      return tables.get(name) || null;\n    },\n\n    /**\n     * Retrieves all registered tables.\n     */\n    getAllTables() {\n      return Array.from(tables.values());\n    },\n\n    /**\n     * Clears all registered tables.\n     * Useful for resetting state between tests.\n     */\n    clearAll() {\n      tables.clear()\n    }\n  }\n})()\n\nexport default TableManager\n", "import TableManager from './tableManager'\nimport TableEntry from './tableEntry'\nimport ScenarioEvent from './scenarioEvent'\nimport Outcome, { TagThreshold } from './outcome'\n\n/**\n * Represents a Scenario which chains table entries through Events and Outcomes.\n */\nexport default class Scenario {\n  /** Name of the scenario */\n  name: string\n  /** RNG providing random() and randomInt(max) */\n  rng: { random(): number; randomInt(max: number): number }\n  /** Registered events in this scenario */\n  events: ScenarioEvent[]\n\n  /**\n   * @param name - Name of the scenario\n   * @param rng - RNG with random() and randomInt(max) methods\n   */\n  constructor(name: string, rng: { random(): number; randomInt(max: number): number }) {\n    this.name = name\n    this.rng = rng\n    this.events = []\n  }\n\n  /**\n   * Registers an Event to the scenario.\n   * @param event - Event to register\n   */\n  register(event: ScenarioEvent) {\n    this.events.push(event)\n  }\n\n  /**\n   * Starts running the scenario from the first registered event.\n   * @returns Array of objects representing the path of entries chosen during scenario execution\n   */\n  async create(): Promise<Array<{\n    tableName: string\n    entry: TableEntry\n    accumulatedTags: Map<string, number>\n  }>> {\n    if (this.events.length === 0) {\n      throw new Error('No events registered in the scenario.')\n    }\n\n    const path: Array<{\n      tableName: string\n      entry: TableEntry\n      accumulatedTags: Map<string, number>\n    }> = []\n\n    const accumulatedTags = new Map<string, number>()\n\n    let currentEvent: ScenarioEvent | undefined = this.events[0]\n\n    while (currentEvent) {\n      const table = TableManager.getTable(currentEvent.tableName)\n      if (!table) {\n        console.warn(`Table \"${currentEvent.tableName}\" not found.`)\n        break\n      }\n\n      const roll = this.rng.randomInt(table.getMaxValue()) + 1\n      const entry = table.getEntry(roll)\n\n      if (!entry) {\n        console.warn(`No entry found for roll ${roll} in table \"${table.name}\".`)\n        break\n      }\n\n      if (entry.tags && entry.tags.length > 0) {\n        for (const tag of entry.tags) {\n          accumulatedTags.set(tag.name, (accumulatedTags.get(tag.name) || 0) + tag.value)\n        }\n      }\n\n      path.push({\n        tableName: table.name,\n        entry,\n        accumulatedTags: new Map(accumulatedTags)\n      })\n\n      // Find the event that matches current table and entry\n      currentEvent = this.events.find(\n        e => e.tableName === table.name && e.entryName === entry.name\n      )\n\n      if (!currentEvent) {\n        break\n      }\n\n      // Determine next outcome by tag thresholds first\n      let nextOutcome = currentEvent.outcomes.find(outcome => {\n        if (!outcome.tagThresholds || outcome.tagThresholds.length === 0) return false\n        return outcome.tagThresholds.every(({ name, minValue }) => {\n          return (accumulatedTags.get(name) || 0) >= minValue\n        })\n      })\n\n      if (nextOutcome) {\n        currentEvent = this.events.find(e => e.tableName === nextOutcome?.tableName)\n        if (!currentEvent) break\n        continue\n      }\n\n      // Likelihood-based outcome selection\n      const cumulative: { outcome: Outcome; cumulativeLikelihood: number }[] = []\n      let sum = 0\n      for (const outcome of currentEvent.outcomes) {\n        if (outcome.tagThresholds && outcome.tagThresholds.length > 0) continue\n        sum += outcome.likelihood\n        cumulative.push({ outcome, cumulativeLikelihood: sum })\n      }\n\n      if (sum === 0) break\n\n      const rand = this.rng.random() * sum\n      nextOutcome = cumulative.find(({ cumulativeLikelihood }) => rand <= cumulativeLikelihood)?.outcome\n      if (!nextOutcome) break\n\n      currentEvent = this.events.find(e => e.tableName === nextOutcome.tableName)\n      if (!currentEvent) break\n    }\n\n    return path\n  }\n}\n", "import Outcome from './outcome'\n\n/**\n * Represents an Event, linking a specific Table and Entry name to possible Outcomes.\n */\nexport default class ScenarioEvent {\n  /** The name of the Table this event is tied to */\n  tableName: string\n  /** The name of the Entry in the Table */\n  entryName: string\n  /** Array of possible outcomes from this event */\n  outcomes: Outcome[]\n\n  /**\n   * @param tableName - Name of the Table this event is tied to\n   * @param entryName - Name of the Entry in the Table\n   * @param outcomes - Array of possible outcomes from this event\n   */\n  constructor(tableName: string, entryName: string, outcomes: Outcome[]) {\n    this.tableName = tableName\n    this.entryName = entryName\n    this.outcomes = outcomes\n  }\n\n  /**\n   * Example async method to randomly select an outcome based on likelihood\n   */\n  async selectOutcome(): Promise<Outcome | null> {\n    if (this.outcomes.length === 0) return null\n\n    const total = this.outcomes.reduce((sum, o) => sum + o.likelihood, 0)\n    const rand = Math.random() * total\n    let cumulative = 0\n\n    for (const outcome of this.outcomes) {\n      cumulative += outcome.likelihood\n      if (rand <= cumulative) return outcome\n    }\n\n    return this.outcomes[this.outcomes.length - 1]\n  }\n}\n", "export interface TagThreshold {\n  name: string\n  minValue: number\n}\n\n/**\n * Represents an outcome from an event, pointing to the next table\n * with a given likelihood and optional tag thresholds.\n */\nexport default class Outcome {\n  /**\n   * Probability between 0 and 1 for this outcome.\n   */\n  likelihood: number\n\n  /**\n   * Name of the table to move to if this outcome is triggered.\n   */\n  tableName: string\n\n  /**\n   * Optional array of tag thresholds required to trigger this outcome.\n   * Each threshold includes a tag name and its minimum required value.\n   */\n  tagThresholds: TagThreshold[]\n\n  /**\n   * Creates a new Outcome instance.\n   * @param likelihood - Probability between 0 and 1 for this outcome.\n   * @param tableName - Name of the table to move to if triggered.\n   * @param tagThresholds - Optional array of tag thresholds to trigger this outcome.\n   */\n  constructor(likelihood: number, tableName: string, tagThresholds: TagThreshold[] = []) {\n    this.likelihood = likelihood\n    this.tableName = tableName\n    this.tagThresholds = tagThresholds\n  }\n}\n", "import Tag from './tag.ts'\n\n/**\n * Represents an entry within a Table, defined by a numeric range, name, and optional tags.\n */\nexport default class TableEntry {\n  start: number\n  end: number\n  name: string\n  tags: Tag[]\n\n  /**\n   * @param start - The starting number of the range (inclusive).\n   * @param end - The ending number of the range (inclusive).\n   * @param name - The name of the entry.\n   * @param tags - Optional array of tags associated with this entry.\n   */\n  constructor(start: number, end: number, name: string, tags: Tag[] = []) {\n    this.start = start\n    this.end = end\n    this.name = name\n    this.tags = tags\n  }\n\n  /**\n   * Determines whether a given value falls within this entry's range.\n   * @param value - The value to test against the entry's range.\n   * @returns True if value is within [start, end], else false.\n   */\n  matches(value: number): boolean {\n    return value >= this.start && value <= this.end\n  }\n}\n", "/**\n * Represents a tag with a name and a numerical value.\n */\nexport default class Tag {\n  name: string;\n  value: number;\n\n  /**\n   * @param name - The name of the tag.\n   * @param value - The numerical value associated with the tag.\n   */\n  constructor(name: string, value: number) {\n    this.name = name;\n    this.value = value;\n  }\n}\n", "/**\n * SimpleSeededRNG\n *\n * Lightweight deterministic RNG for browsers.\n * Based on Mulberry32: fast, good-quality random stream from a seed.\n */\nexport default class SimpleSeededRNG {\n  private state: number\n\n  constructor(seed: number | string) {\n    // Convert string seeds to numeric hash\n    if (typeof seed === 'string') {\n      let h = 1779033703 ^ seed.length\n      for (let i = 0; i < seed.length; i++) {\n        h = Math.imul(h ^ seed.charCodeAt(i), 3432918353)\n        h = (h << 13) | (h >>> 19)\n      }\n      this.state = (h >>> 0)\n    } else {\n      this.state = seed >>> 0\n    }\n  }\n\n  /** Returns a float between 0 (inclusive) and 1 (exclusive). */\n  random(): number {\n    this.state += 0x6D2B79F5\n    let t = this.state\n    t = Math.imul(t ^ (t >>> 15), t | 1)\n    t ^= t + Math.imul(t ^ (t >>> 7), t | 61)\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296\n  }\n\n  /** Returns an integer between min (inclusive) and max (exclusive). */\n  randomInt(min: number, max: number): number {\n    return Math.floor(this.random() * (max - min)) + min\n  }\n}\n"],
  "mappings": "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",
  "names": []
}
