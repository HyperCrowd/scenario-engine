{
  "version": 3,
  "sources": ["../src/index.ts", "../src/table.ts", "../src/tableManager.ts", "../src/scenarioEvent.ts", "../src/tag.ts", "../src/outcome.ts", "../src/rng.ts", "../src/journey.ts", "../src/scenario.ts", "../src/tableEntry.ts"],
  "sourcesContent": ["// Main exports\nexport { default as Scenario } from './scenario'\nexport { default as ScenarioEvent } from './scenarioEvent'\nexport { default as Outcome } from './outcome'\nexport { default as Table } from './table'\nexport { default as TableEntry } from './tableEntry'\nexport { default as TableManager } from './tableManager'\nexport { default as Tag } from './tag'\nexport { default as SimpleSeededRNG } from './rng'\nexport { default as Journey } from './journey'\n", "import TableEntry from './tableEntry'\nimport TableManager from './tableManager'\n\n/**\n * Represents a table of entries that can be queried based on numeric input.\n * Automatically registers itself with the TableManager singleton.\n */\nexport default class Table {\n  name: string\n  entries: TableEntry[]\n\n  /**\n   * @param name - The unique name of the table.\n   * @param entries - Optional array of entries to initialize the table with.\n   */\n  constructor(name: string, entries: TableEntry[] = []) {\n    this.name = name\n    this.entries = entries\n\n    // Automatically register with TableManager\n    TableManager.registerTable(this)\n  }\n\n  /**\n   * Adds a new entry to the table.\n   * @param entry - The entry to add.\n   */\n  addEntry(entry: TableEntry): void {\n    this.entries.push(entry)\n  }\n\n  /**\n   * Gets the highest `end` value across all entries in the table.\n   * Useful for determining the max rollable number.\n   * @returns The maximum end value or 0 if the table is empty.\n   */\n  getMaxValue(): number {\n    if (this.entries.length === 0) return 0\n    return Math.max(...this.entries.map(entry => entry.end))\n  }\n\n  /**\n   * Retrieves the entry that matches a given numeric input.\n   * @param value - The number to look up.\n   * @returns The matching entry, or null if no match is found.\n   */\n  getEntry(value: number): TableEntry | null {\n    return this.entries.find(entry => entry.matches(value)) ?? null\n  }\n\n  /**\n   * Returns a string of keys for the table\n   */\n  static getKeys(tableName: string): string[] {\n    const table = TableManager.getTable(tableName)\n\n    if (!table) {\n      throw new RangeError(`\"${table}\" is not a table`)\n    }\n\n    return table.entries.map((e) => e.name)\n  }\n}\n", "import Table from './table'\n\n/**\n * Singleton manager that keeps track of all registered tables.\n * Tables are registered automatically upon instantiation.\n */\nconst TableManager = (() => {\n  const tables: Map<string, Table> = new Map()\n\n  return {\n    /**\n     * Registers a new table by name.\n     */\n    registerTable(table: Table) {\n      if (!(table instanceof Table)) {\n        throw new Error(\"Only instances of Table can be registered.\")\n      }\n      \n      if (tables.has(table.name)) {\n        throw new Error(`Table with name \"${table.name}\" is already registered.`)\n      }\n      tables.set(table.name, table)\n    },\n\n    /**\n     * Retrieves a registered table by name.\n     */\n    getTable(name: string) {\n      return tables.get(name) || null;\n    },\n\n    /**\n     * Retrieves all registered tables.\n     */\n    getAllTables() {\n      return Array.from(tables.values());\n    },\n\n    /**\n     * Clears all registered tables.\n     * Useful for resetting state between tests.\n     */\n    clearAll() {\n      tables.clear()\n    }\n  }\n})()\n\nexport default TableManager\n", "import Outcome from './outcome'\n\n/**\n * Represents an Event, linking a specific Table and Entry name to possible Outcomes.\n */\nexport default class ScenarioEvent {\n  /** The name of the Table this event is tied to */\n  tableName: string\n  /** The name of the Entry in the Table */\n  entryName: string\n  /** Array of possible outcomes from this event */\n  outcomes: Outcome[]\n\n  /**\n   * @param tableName - Name of the Table this event is tied to\n   * @param entryName - Name of the Entry in the Table\n   * @param outcomes - Array of possible outcomes from this event\n   */\n  constructor(tableName: string, entryName: string, outcomes: Outcome[]) {\n    this.tableName = tableName\n    this.entryName = entryName\n    this.outcomes = outcomes\n  }\n}\n", "import Journey, { type JourneyTags } from './journey'\n\nexport type TagModifier = (journey: Journey) => Tag[] | Record<string, number>\nexport type ComplexTag = (TagModifier | Tag)[] | Record<string, number>\n/**\n * Represents a tag with a name and a numerical value.\n */\nexport default class Tag {\n  name: string;\n  value: number;\n\n  /**\n   * @param name - The name of the tag.\n   * @param value - The numerical value associated with the tag.\n   */\n  constructor(name: string, value: number) {\n    this.name = name;\n    this.value = value;\n  }\n\n  /**\n   * Syntatic sugar helper\n   */\n  static normalize (tags: ComplexTag) {\n    if (tags instanceof Array) {\n      return tags\n    } else {\n      const result: Tag[] = []\n\n      for (const [ name, value ] of Object.entries(tags)) {\n        result.push(new Tag(name, value))\n      }\n\n      return result\n    }\n  }\n\n  /**\n   * \n   */\n  static unwrap(journey: Journey, tags: ComplexTag) {\n    const result: Tag[] = []\n\n    for(const tag of Tag.normalize(tags)) {\n      if (tag instanceof Tag) {\n        result.push(tag)\n      } else {\n        const normalized = Tag.normalize(tag(journey)) as Tag[]\n        normalized.forEach(tag => result.push(tag))\n      }\n    }\n\n    return result\n  }\n\n  /**\n   * \n   */\n  apply (journey: Journey, tags: (TagModifier | Tag)[]) {\n    const target = Tag.unwrap(journey, tags)\n\n    for (const tag of target) {\n      if(tag.name === this.name) {\n        tag.value += this.value\n      }\n    }\n\n    return target\n  }\n\n  /**\n   * \n   */\n  update (tags: Tag[]) {\n    let didUpdate = false\n\n    tags.forEach(t => {\n      if(t.name === this.name) {\n        this.value += t.value\n        didUpdate = true\n      }\n    })\n\n    return didUpdate\n  }\n}\n", "import Tag, { TagModifier } from './tag'\n\n/**\n * Represents an outcome from an event, pointing to the next table\n * with a given likelihood and optional tag thresholds.\n */\nexport default class Outcome {\n  /**\n   * Probability between 0 and 1 for this outcome.\n   */\n  likelihood: number\n\n  /**\n   * Name of the table to move to if this outcome is triggered.\n   */\n  tableName: string\n\n  /**\n   * Optional array of tag thresholds required to trigger this outcome.\n   * Each threshold includes a tag name and its minimum required value.\n   */\n  tagThresholds: (TagModifier | Tag)[] = []\n\n  /**\n   * Creates a new Outcome instance.\n   * @param likelihood - Probability between 0 and 1 for this outcome.\n   * @param tableName - Name of the table to move to if triggered.\n   * @param tagThresholds - Optional array of tag thresholds to trigger this outcome.\n   */\n  constructor(likelihood: number, tableName: string, tagThresholds: (TagModifier | Tag | Record<string, number>)[] | Record<string, number> = []) {\n    this.likelihood = likelihood\n    this.tableName = tableName\n    const thresholds: (TagModifier | Tag)[] = []\n\n    if (tagThresholds instanceof Array) {\n      for (const tag of tagThresholds) {\n        if (tag instanceof Function || tag instanceof Tag) {\n          thresholds.push(tag)\n        } else {\n          for (const [name, value] of Object.entries(tag))\n            thresholds.push(new Tag(name, value))\n          }\n      }\n    } else {\n      for (const [name, value] of Object.entries(tagThresholds)) {\n        thresholds.push(new Tag(name, value))\n      }\n    }\n\n    this.tagThresholds = thresholds\n  }\n}\n", "/**\n * SimpleSeededRNG\n *\n * Lightweight deterministic RNG for browsers.\n * Based on Mulberry32: fast, good-quality random stream from a seed.\n * If no seed is provided, uses crypto.getRandomValues for unseeded randomness.\n */\nexport default class SimpleSeededRNG {\n  private state: number\n  readonly seed: string | number | undefined\n\n  constructor(seed?: number | string) {\n    if (seed === undefined) {\n      // Use cryptographically secure randomness\n      const array = new Uint32Array(1)\n      crypto.getRandomValues(array)\n      this.state = array[0]\n    } else if (typeof seed === 'string') {\n      let h = 1779033703 ^ seed.length\n      for (let i = 0; i < seed.length; i++) {\n        h = Math.imul(h ^ seed.charCodeAt(i), 3432918353)\n        h = (h << 13) | (h >>> 19)\n      }\n      this.state = h >>> 0\n    } else {\n      this.state = seed >>> 0\n    }\n    this.seed = seed\n  }\n\n  /** Returns a float between 0 (inclusive) and 1 (exclusive). */\n  random(): number {\n    this.state += 0x6D2B79F5\n    let t = this.state\n    t = Math.imul(t ^ (t >>> 15), t | 1)\n    t ^= t + Math.imul(t ^ (t >>> 7), t | 61)\n    return ((t ^ (t >>> 14)) >>> 0) / 4294967296\n  }\n\n  /** Returns an integer between min (inclusive) and max (exclusive). */\n  randomInt(min: number, max: number): number {\n    return Math.floor(this.random() * (max - min)) + min\n  }\n}\n", "import Tag, { TagModifier, ComplexTag } from './tag'\nimport TableEntry from './tableEntry'\n\nexport type JourneyTags = Map<string, number>\n\nexport type PathEvent = {\n  tableName: string\n  entry: string\n  description: string\n  roll: number\n  tags: Map<string, number>\n}\n\n/**\n * \n */\nexport default class Journey {\n  tags: JourneyTags\n  path: PathEvent[] \n\n  constructor (tags: JourneyTags = new Map(), path: PathEvent[] = []) {\n    this.tags = tags\n    this.path = path\n  }\n\n  /**\n   * \n   */\n  getPaths(criteria: { tableName?: string, entry?: string, rollEquals?: number, rollLessThan?: number, rollGreaterThan?: number } = {}) {\n    const results = this.path.filter(path => {\n      let found = false\n      if(criteria.tableName !== undefined) {\n        found = criteria.tableName === path.tableName\n      }\n\n      if(criteria.entry !== undefined) {\n        found = criteria.entry === path.entry\n      }\n\n      if(criteria.rollEquals !== undefined) {\n        found = criteria.rollEquals === path.roll\n      }\n\n      if(criteria.rollLessThan !== undefined) {\n        found = criteria.rollLessThan < path.roll\n      }\n\n      if(criteria.rollGreaterThan !== undefined) {\n        found = criteria.rollGreaterThan > path.roll\n      }\n\n      return found\n    })\n\n    return results\n  }\n\n  /**\n   * \n   */\n  hasPath (criteria: { tableName?: string, entry?: string, rollEquals?: number, rollLessThan?: number, rollGreaterThan?: number } = {}, count: number = 0) {\n    const result = this.getPaths(criteria)\n\n    return result.length > count\n  }\n\n  /**\n   * \n   */\n  hasTag(name: string, criteria: { equals?: number, lessThan?: number, greaterThan?: number } = {}) {\n    const value = this.tags.get(name)\n\n    if (value === undefined) {\n      return false\n    }\n\n    if (criteria.equals !== undefined) {\n      return value === criteria.equals\n    } else if (criteria.lessThan !== undefined) {\n      return value < criteria.lessThan\n    } else if (criteria.greaterThan !== undefined) {\n      return value > criteria.greaterThan\n    } else {\n      return true\n    }\n  }\n\n  /**\n   *\n   */\n  hasTags () {\n    return this.tags.size > 0\n  }\n\n  /**\n   * \n   */\n  addPathEvent (roll: number, tableName: string, entry: TableEntry) {\n    this.accumulate(entry.tags)\n\n    const pathEvent: PathEvent = {\n      roll,\n      tableName,\n      entry: entry.name,\n      description: entry.description,\n      tags: new Map(this.tags)\n    }\n\n    this.path.push(pathEvent)\n\n    return pathEvent\n  }\n\n  /**\n   * \n   */\n  accumulate (tags: (TagModifier | Tag)[]) {\n    const target = Tag.unwrap(this, tags)\n\n    for (const tag of target) {\n      const value = this.tags.get(tag.name) || 0\n      this.tags.set(tag.name, value + tag.value)\n    }\n\n    return target\n  }\n\n  /**\n   * Is the journey activated?\n   */\n  isActivated (tags: ComplexTag): boolean {\n    const normalized = Tag.normalize(tags)\n\n    return normalized.every((tag) => {\n      if (tag instanceof Tag) {\n        // Dealing with a tag\n        return (this.tags.get(tag.name) || 0) >= tag.value\n      } else {\n        // Dealing with a TagModifier function\n        return this.isActivated(tag(this))\n      }\n      \n    })\n  }\n}", "import TableManager from './tableManager'\nimport ScenarioEvent from './scenarioEvent'\nimport Outcome from './outcome'\nimport SimpleSeededRNG from './rng'\nimport Table from './table'\nimport Journey, { type JourneyTags, type PathEvent } from './journey'\n\n/**\n * Represents a Scenario which chains table entries through Events and Outcomes.\n */\nexport default class Scenario {\n  /** Name of the scenario */\n  name: string\n  /** RNG providing random() and randomInt(max) */\n  rng: SimpleSeededRNG\n  /** Registered events in this scenario */\n  events: ScenarioEvent[]\n  /** The journey taken through this scenario */\n  journey: Journey\n  /** Outputs a journey */\n  debug: string = ''\n\n  /**\n   * Constructor\n   */\n  constructor(name: string, rng: SimpleSeededRNG = new SimpleSeededRNG(), journey: Journey = new Journey()) {\n    this.name = name\n    this.rng = rng\n    this.events = []\n    this.journey = journey\n  }\n\n  /**\n   * Gets a table\n   */\n  private getTable (tableName: string)  {\n    const table = TableManager.getTable(tableName)\n\n    if (!table) {\n      throw new Error(`Table \"${tableName}\" not found.`)\n    }\n\n    return table\n  }\n\n  /**\n   * Gets a Table Entry\n   */\n  private getEntry (table: Table, journey: Journey = this.journey) {\n    const roll = this.rng.randomInt(0, table.getMaxValue()) + 1\n    const entry = table.getEntry(roll)\n\n    if (!entry) {\n      throw new Error(`No entry found for roll ${roll} in table \"${table.name}\".`)\n    }\n\n    return {\n      roll, entry\n    }\n  }\n\n  /**\n   * Gets a random Outcome from a Scenario Event\n   */\n  private getRandomOutcome(scenarioEvent: ScenarioEvent, outcomes: Outcome[] = scenarioEvent.outcomes): Outcome | false  {\n    const cumulative: { outcome: Outcome; cumulativeLikelihood: number }[] = []\n    let sum = 0\n\n    for (const outcome of outcomes) {\n      sum += outcome.likelihood\n      cumulative.push({ outcome, cumulativeLikelihood: sum })\n    }\n\n    const rand = this.rng.random() * sum\n    const outcome = cumulative.find(({ cumulativeLikelihood }) => rand <= cumulativeLikelihood)?.outcome\n\n    if (!outcome) {\n      return false\n    }\n\n    return outcome\n  }\n\n  /**\n   * Gets possible outcomes based on how the Journey and the Scenario Event intersect\n   */\n  private getPossibleOutcomes (scenarioEvent: ScenarioEvent, journey: Journey = this.journey) {\n    const hasThresholds = scenarioEvent.outcomes.filter(outcome => {\n      return outcome.tagThresholds && outcome.tagThresholds.length > 0\n    }).length > 0\n\n    const possibleOutcomes: Outcome[] = scenarioEvent.outcomes.filter(outcome => {\n      if (hasThresholds) {\n        // This scenario event has thresholds, use them\n        if (!outcome.tagThresholds || outcome.tagThresholds.length === 0) {\n          return false\n        }\n\n        return journey.isActivated(outcome.tagThresholds)\n      } else {\n        // This scenario event has no thresholds, use them\n        return outcome\n      }\n    })\n\n    if (hasThresholds && possibleOutcomes.length === 0) {\n      // All threshold checks have failed, use all non-thresholded outcomesinstead\n      return scenarioEvent.outcomes.filter(outcome => {\n        return outcome.tagThresholds && outcome.tagThresholds.length === 0\n      })\n    } else {\n      // Return all possible outcomes\n      return possibleOutcomes\n    }\n  }\n\n  /**\n   * Gets the next outcome of a Scenario Event\n   */\n  private getNextOutcome(scenarioEvent: ScenarioEvent, criteria?: { byTableName?: string, randomly?: boolean, byTags?: JourneyTags}, journey: Journey = this.journey): Outcome | undefined {\n    let outcome: Outcome | undefined\n\n    if (criteria !== undefined) {\n      const journey = new Journey(criteria.byTags ?? new Map<string, number>())\n      const possibleOutcomes = this.getPossibleOutcomes(scenarioEvent, journey)\n\n      if (possibleOutcomes.length === 0) {\n        this.trace('No possible outcomes!')\n        return\n      }\n\n      if (journey.hasTags() || criteria.randomly) {\n        /**\n         * Find outcome by tags\n         **/\n        this.trace(`Getting 1 of ${possibleOutcomes.length} random valid outcome...`)\n\n        const possibleOutcome = this.getRandomOutcome(scenarioEvent, possibleOutcomes)\n\n        if (possibleOutcome) {\n          outcome = possibleOutcome\n        }\n      }     \n\n      if (outcome === undefined && criteria.byTableName) {\n        /**\n         * Find outcome by table name\n         */\n        this.trace('Getting outcome by table name...')\n        const possibleOutcome = scenarioEvent.outcomes.find((o) => o.tableName === criteria.byTableName)\n\n        if (possibleOutcome) {\n          outcome = possibleOutcome\n        }\n      }\n    } else if (criteria === undefined) {\n      /**\n       * Find outcome by probability\n       */\n      this.trace('Getting random outcome...')\n      const possibleOutcome = this.getRandomOutcome(scenarioEvent)\n\n      if (possibleOutcome) {\n        outcome = possibleOutcome\n      }\n\n      \n    } else {\n      throw new Error(`Invalid criterial: ${JSON.stringify(criteria, null, 2)}`)\n    }\n\n    return outcome\n  }\n\n  /**\n   * Adds a Path Event to the Journey\n   */\n  private addPathEvent (tableName: string, journey: Journey = this.journey) {\n    const table = this.getTable(tableName)\n    const { roll, entry } = this.getEntry(table, journey)\n    this.trace(`Adding \"${tableName}/${entry.name}\" to path`)\n    return journey.addPathEvent(roll, tableName, entry)\n  }\n\n  /**\n   * Gets an event by Table Entry\n   */\n  getEvent(tableName: string, entryName: string) {\n    return this.events.find(e => e.tableName === tableName && e.entryName === entryName)\n  }\n\n  /**\n   * Merges outcomes into a Scenario Event\n   */\n  mergeOutcomes (newEvent: ScenarioEvent, existingOutcomes: Outcome[], addIfMissing = true) {\n    for (const outcome of newEvent.outcomes) {\n      const existingOutcome = existingOutcomes.find(\n        o => outcome.tableName === o.tableName && outcome.likelihood === o.likelihood\n      )\n\n      if (existingOutcome) {\n        for (const threshold of outcome.tagThresholds) {\n          existingOutcome.tagThresholds.push(threshold)\n        }\n      } else {\n        // The outcome does not exist, add it\n        if (addIfMissing) {\n          existingOutcomes.push(outcome)\n        }\n      }\n    }\n  }\n\n  /**\n   * Registers an Event to the scenario.\n   */\n  add(tableName: string, entryName: string | string[], outcomes: Outcome[] | Record<string, number>) {\n    try {\n      const normalizedOutcomes: Outcome[] = outcomes instanceof Array\n        ? outcomes\n        : Object.entries(outcomes).map(([ tableName, likelihood]) => new Outcome(likelihood, tableName))\n\n      const entryNames = entryName instanceof Array\n        ? entryName\n        : [entryName]\n\n      for (const name of entryNames) {\n        const event = new ScenarioEvent(tableName, name, normalizedOutcomes)\n        const existingEvent = this.getEvent(event.tableName, event.entryName)\n\n        if (existingEvent !== undefined) {\n          // The event already exists\n          this.mergeOutcomes(event, existingEvent.outcomes)\n        } else {\n          // The event does not exist, add it\n          this.events.push(event)\n        }\n      }\n    } catch (e) {\n      console.log({ outcomes })\n      throw e\n    }\n  }\n\n  /**\n   * Tracing\n   */\n  trace (message: string, object: Object | string = '') {\n    if (this.debug !== '') {\n      const objMsg = object !== '' ? JSON.stringify(object, null, 2) : ''\n      console.log(this.debug, message, objMsg)\n    }\n  }\n\n  /**\n   * Starts running the scenario from the first registered event.\n   */\n  run(journey: Journey = this.journey, currentEvent: ScenarioEvent | undefined = this.events[0], skipInitialRoll: boolean = false): Journey {\n    if (this.events.length === 0) {\n      throw new Error('No events registered in the scenario.')\n    }\n\n    let pathEvent: PathEvent\n    \n    if (skipInitialRoll) {\n      // We already rolled for this event in the parent call\n      this.trace(`Using existing path entry for ${currentEvent.tableName}`)\n      pathEvent = journey.path[journey.path.length - 1] // Get the last added path event\n    } else {\n      // Normal flow: roll on the current event's table\n      this.trace(`Adding path for ${currentEvent.tableName}`)\n      pathEvent = this.addPathEvent(currentEvent.tableName, journey)\n    }\n\n    this.trace(`Searching for \"${pathEvent.tableName}/${pathEvent.entry}\" event...`)\n\n    const nextEvent = this.events.find((e) =>\n      pathEvent.tableName === e.tableName && pathEvent.entry === e.entryName\n    )\n\n    if (nextEvent === undefined) {\n      this.trace('Could not find it, bailing')\n      return journey\n    }\n\n    this.trace('Found it!')\n    this.trace('Searching for the next outcome with tags:', journey.tags)\n\n    const outcome = this.getNextOutcome(nextEvent, {\n      byTags: journey.tags,\n      randomly: true\n    })\n\n    if (outcome) {\n      this.trace('There is a next outcome')\n      \n      // Roll on the outcome table ONCE\n      const nextPathEvent = this.addPathEvent(outcome.tableName, journey)\n      \n      // Find the SPECIFIC event matching this roll\n      const matchedEvent = this.events.find((e) => \n        e.tableName === nextPathEvent.tableName && \n        e.entryName === nextPathEvent.entry\n      )\n      \n      if (matchedEvent) {\n        this.trace(`Running matched event: ${matchedEvent.entryName}`)\n\n        if(this.debug !== '') {\n          this.debug += '.'\n        }\n\n        // Skip the initial roll since we just did it\n        journey = this.run(journey, matchedEvent, true)\n      } else {\n        this.trace(`No event defined for ${nextPathEvent.tableName}/${nextPathEvent.entry}`)\n      }\n    }\n\n    this.trace(`Returning from event`)\n    this.debug = this.debug.slice(0, -1)\n    return journey\n  }\n}\n", "import Tag, { TagModifier, ComplexTag } from './tag.ts'\n\n/**\n * Represents an entry within a Table, defined by a numeric range, name, and optional tags.\n */\nexport default class TableEntry {\n  start: number\n  end: number\n  name: string\n  description: string\n  tags: (TagModifier | Tag)[]\n\n  /**\n   * @param start - The starting number of the range (inclusive).\n   * @param end - The ending number of the range (inclusive).\n   * @param name - The name of the entry.\n   * @param tags - Optional array of tags associated with this entry.\n   */\n  constructor(start: number, end: number, name: string, description: string = name, tags: ComplexTag = []) {\n    this.start = start\n    this.end = end\n    this.name = name\n    this.description = description\n    this.tags = Tag.normalize(tags)\n  }\n\n  /**\n   * Determines whether a given value falls within this entry's range.\n   * @param value - The value to test against the entry's range.\n   * @returns True if value is within [start, end], else false.\n   */\n  matches(value: number): boolean {\n    return value >= this.start && value <= this.end\n  }\n}\n"],
  "mappings": "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",
  "names": ["tag", "outcome", "journey", "tableName"]
}
